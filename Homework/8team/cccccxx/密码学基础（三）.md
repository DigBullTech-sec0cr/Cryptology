### 密码学基础（三）
### 对称密码
对称密码包括任何加密形式，其中同一个密钥既用于加密也用于解密所涉及的文本。

计算机的操作对象不是文字，而是由0和1组成的*比特序列*,比如:010000111。将现实生活中的东西映射成比特序列的操作称为`编码`。将字母表中的字母逐一进行编码，这种编码规则叫做`ASCII`。<br>
### 一次性密码本
一次性密码本是以随机的密钥（key）组成明文，且只使用一次。
一次性密码本的原理是：将明文和一串随机的比特序列进行XOR运算。<br>
**举个栗子**
- 将明文midnight的字符通过ASCII进行编码，产生一串比特序列。
产生明文如下：<br>
```
m->01101101
i->01101001
d->01100100
n->01101110
i->01101001
g->01100111
h->01101000
t->01110100
```
- 产生一段与明文长度相同的随机比特序列。可以用投硬币的方式产生。<br>
01101011 11111010 01001000 11011000 01100101 11010101 10101111 00011100 密钥
- 将明文与密钥进行XOR运算并得到新的比特序列。<br>
```
01101101 01101001 01100100 01101110 01101001 01100111 01101000 01110100   明文
                                   XOR
01101011 11111010 01001000 11011000 01100101 11010101 10101111 00011100   密钥
00000110 10010011 00101100 10110110 00001100 10110010 11000111 01101000   密文
```

- 一次性密码本的解密，其实就是加密的反向运算，也就是说，用密文和密钥进行XOR运算，就可以得到明文。各位同学自己尝试一下解密吧！<br>
>**CTF长征一小步**<br>
为什么一次性密码本是无法破译的？<br>
因为其密钥是随机的且该密码只使用一次。
**CTF长征小半步**<br>
bit、byte、word的概念和关系。<br>

•bit、byte、word的概念和关系。
字 word ：2个字节组成一个字。
字节 byte ：“字节”是通过网络传输信息（或在硬盘或内存中存储信息）的单位。
位 bit： “位”或“比特”，是计算机运算的基础；
字长是指字的长度（字的位数）
1字=2字节(1 word = 2 byte) 
1字节=8位(1 byte = 8bit)
Bit 和Byte的区别：
比如：USB2.0标准接口传输速率480Mbps，就有人误解为480兆/秒，同样网络带宽2MB,就易误解为2兆/秒。实际上，480Mbps应为480兆比特/秒或480兆位/秒，它等于“60兆字节/秒”；同样，2MB，就应该是256兆字节/秒。

### DES
DES是将64比特明文加密成64比特密文的`对称密码算法`，它的`密钥长度`为56比特，在密钥中每隔7比特就会插入一个用于错误检查的比特,所以一共64比特。<br>
DES是以64比特明文为一个单位来进行加密的，这64比特的一个单位成为一个分组，所以DES也是分组密码的一种。DES每次只能加密64比特的数据，如果加密的明文比较长就需要对DES加密过程进行迭代，迭代的加密方式称为*模式*，详见分组密码。<br>

### DES结构（Feistel网络）
DES结构也叫Feistel网络，在Feistel网络中，加密的各个步骤成为`轮`，整个加密过程，就是若干次轮的循环。下图展示Feistel网络的一轮计算，DES是16轮循环的Feistel网络<br>

![image](../Src/cr_base_3/1511924443498.png) 
<br>
 中间的子密钥指本轮加密的密钥，Feistel网络每轮使用不同的子密钥。`轮函数`可以根据“右侧”和子密钥生成对“左侧”进行加密的比特序列。然后，我们用XOR将轮函数的输出与“左侧”进行合并。<br>
 每一轮的具体计算过程如下：<br>
 - 输入数据等分成左右两分。
 - 输入的右侧直接发送到输出的左侧。
 - 输入的右侧发送到轮函数。
 - 轮函数根据右侧数据和子密钥，计算出一串看上去随机的比特序列
 - 上一步的比特序列与左侧数据进行XOR运算，并把结果作为加密的左侧。
 通过上述过程，可以看到，右侧并没有被加密，所以我们需要用不同的子密钥对一轮的处理多次，并在每两轮处理之间将左右数据对调。就像下面的模型图<br>
![image](../Src/cr_base_3/1511924512167.png)
<br>

### DES解密
DES的解密可以使用和加密完全相同的结构，只需要按照相反的顺序来使用子密钥就可以了。也就是说，用相同的子密钥运行两次Feistel网络，就可以实现“明文->密文->明文”的过程。同理，多轮的Feistel网络，只需要按照n->1的顺序使用子密钥就可以实现解密。<br>

![image](../Src/cr_base_3/1511924666655.png)

### 三重DES
三重DES（3DES）就是将DES重复三次得到的一种密码算法。明文经三次DES处理才会变成密文，由于DES的密钥是56比特，所以3DES的密钥长度是168比特。三重DES的加密过程是“加密->**解密**->加密”。<br>
三重DES的解密过程，刚好和加密过程相反，是执行“解密->加密->解密”的操作。<br>
关于三重DES加密有四种不同的模式，罗列如下：
1. DES-EEE3模式。使用三个不同密钥（k1,k2,k3），采用三次加密算法。<br>
2. DES-EDE3模式。使用三个不同密钥（k1,k2,k3），采用加密-解密-加密算法。<br>
3. DES-EEE2模式。使用两个不同密钥（k1 = k3,k2），采用三次加密算法。<br>
4. DES-EDE2模式。使用两个不同密钥（k1 = k3,k2），采用加密-解密-加密算法。<br>

两个密钥的三重DES<br>
由于DES密钥只有56bit，易于遭受穷举时攻击。作为一种替代加密方案，Tuchman提出使用两个密钥的三重DES加密方法，并在1985年成为美国的一个商用加密标准。该方法使用两个密钥（K1=K2），执行三次DES算法，如图2所示。加密的过程是加密-解密-加密，解密的过程是解密-加密-解密。<br>
### AES
Rijndael分组密码算法于2000年被选为新一代AES。Rijndael分组长度为128比特，密钥长度以32item为单位，在128比特到256比特范围内选择。该算法由多个*轮*组成，使用SPN结构。<br>
Rijndael输入分组128比特，Rijindael的加密过程分四步：<br>
- 首先SubBytes处理,逐字节的对16字节的输入进行处理。以每个字节的值为索引，从一张替换表中找到对应得值。也就是将一个字节的值换成另一个字节的值。<br>
- 其次ShiftRows处理：将上一步输出以字节为单位进行打乱处理。
- MixColumns处理，对四字节的值进行比特运算，把他变成另一个4字节的值。
- AddRoundKey处理，将MixColumns的输出与轮密钥进行XOR。<br>
在Rijndael中，需要进行10~14轮上述运算。每轮计算模型如下图所示<br>

![image](../Src/cr_base_3/1511924752979.png)
<br>
Rijindael不能像Feistel一样用同一结构实现加解密，而是通过每一步都进行反向运算来实现解密。<br>

![image](../Src/cr_base_3/1511924849906.png)
<br>



## 分组密码
`分组密码`是一种对称密钥算法。它将明文分成多个等长的`块`，使用确定的算法和对称密钥对每组分别加密解密。典型的分组大小是64位或128位。

![image](../Src/cr_base_3/1511431425340.png)


分组密码算法只能加密固定长度的分组，若要加密超过分组密码长度的明文，就需要对分组密码进行迭代，迭代后的最后一块数据需要使用合适的填充方式将数据扩展到与分组长度相等的长度。这种迭代的方法我们称为分组密码的模式
分组密码的模式主要有下列5种：
ECB（Electronic CodeBook mode）：电子密码本模式
CBC（Cipher Block Chaining mode）：密码分组链接模式
CFB（Cipher FeedBack mode）：密文反馈模式
OFB（Output FeedBack mode）：输出反馈模式
CTR（CounTeR mode）：计数器模式

### ECB模式
ECB模式是需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。由于在此模式中，明文块与密文块是一一对应的关系，所以如果明文中存在多个相同的明文块，则这些明文块会被加密成相同的密文块，这是ECB模式的缺点。

![image](../Src/cr_base_3/1511835304025.png)

在破译时，只要观察密文，就能知道明文中存在怎样的重复组合，并以此为线索进行破译。由此可见，ECB模式不能很好的隐藏数据模式，不能提供严格的数据保密性，因此不会在实际中使用。

![image](../Src/cr_base_3/1511854943463.png)

- ECB攻击实例：
[利用ECB加密缺陷突破cookie加密](http://www.freebuf.com/news/topnews/56506.html)

### CBC模式
CBC模式是将前一个密文分组与当前明文分组的内容进行XOR运算，再进行加密。当加密第一个明文分组时，用一个事先准备好的比特序列来代替“前一个密文分组”，这个比特序列称为“初始化向量”。通常，每次加密的初始化向量都是随机的。
目前，互联网安全的通信协议SSL/TLS就是使用CBC加密模式。
找一个比特序列充当“初始化向量”，与第一组明文进行XOR，运算，得出第一组密文，接下来将第一组密文与第二组明文进行XOR运算，得第二组密文，并重复。
![image](../Src/cr_base_3/1511859648992.png)

![image](../Src/cr_base_3/1511861577790.png)

CBC模式的主要缺点在于加密过程是串行的，无法被并行化，而且消息必须被填充到块大小的整数倍。也因为串行的特点，明文中的微小改变会导致其后的全部密文块发生改变。而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，解密过程可以被并行化，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。
- CBC攻击实例：
[CBC字节翻转攻击](http://sec.chinabyte.com/228/13511728.shtml)

### CFB模式
在CFB模式中，“前一个密文分组”经过密码算法生成的比特序列称为密钥流。我们注意到，CFB的明文分组和密文分组之间没有通过密码算法进行加密，仅有一个XOR运算，事实上，明文分组与密钥流进行XOR，得到的结果就是随机的密文分组，XOR充当了加密的角色。
找一个比特序列充当“初始化向量”，与第一组明文进行XOR，运算，得出第一组密文，将第一组密文加密，接下来将加密过后的第一组密文与第二组明文进行XOR运算，得第二组密文，并重复。
![image](../Src/cr_base_3/1511862786250.png)

![image](../Src/cr_base_3/1511862858104.png)
![image](./image/1516872789988.png)  
![image](./image/1516872805709.png)

### OFB模式
OFB模式可以将密码分组变成同步的密钥流，然后将其与明文分组进行XOR，得到密文。这一点OFB与CFB非常相似。
OFB与CFB不同的地方：OFB为对前一次初始化向量加密，而CFB对前一组密文加密。
![image](../Src/cr_base_3/1511865893404.png)

![image](../Src/cr_base_3/1511866093369.png)
![image](./image/1516872997883.png)
![image](./image/1516873008914.png)

### CTR模式
CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。它可以以任意顺序对分组进行加密和解密，这意味着能够实现并行计算。

![image](../Src/cr_base_3/1511866747703.png)
![image](./image/1516873255167.png)
![image](./image/1516873267528.png)

### 分组密码模式比较
![image](../Src/cr_base_3/1511867144781.png)

## 公钥密码
公钥密码中，密钥分为*加密密钥*和*解密秘钥*两种。加密密钥一般是公开的，称为公钥。解密秘钥由自己保存绝不公开，称为私钥。公钥和私钥统称为密钥对<br>
公钥密码又称为非对称密码，拥有公钥密码的用户分别拥有加密密钥和解密密钥。通过加密密钥不能得到解密密钥。并且加密密钥是公开的。
### RSA
RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。
- 加密：密文=明文^E mod N
- 解密：明文=密文^D mod N
(a^c表示a的c次方)。<br>
公钥：（E,N)； 私钥：（D,N）<br>
**如何生成密钥对呢？？？**<br>
```
1. 生成N
   N=p* q(p,q是两个非常大的质数)
2. 生成L（L是生成秘钥对过程中使用的数）
   L=lcm(p-1,q-1) (L是p-1和q-1的最小公倍数)
3. 生成E
   1<E<L
   gcd(E,L)=1(E,L的最大公约数为1)
   检查E,L的最大公约数是否为1，可以用辗转相除法求公约数。感兴趣的同学可以自行拓展，在此不做赘述。<br>
4. 生成D
   1<D<L
   E* DmodL=1
```
### 中间人攻击
`中间人攻击`是一种针对机密性的有效攻击。攻击者混入发送者和接收者之间，对发送者伪装成接受者，对接收者伪装成发送者。<br>

## 单向散列函数
`单向散列函数`也叫`哈希函数`，它有一个输入和一个输出，输入称为消息，输出称为散列值，也叫信息摘要或者指纹<br>
单向散列函数是一种采集文件指纹的技术，单向散列函数产生的散列值，相当于消息的指纹。可以用来检测软件是否被篡改。<br>
单向散列函数可以根据任意长度的消息计算出固定长度的散列值，能够跨苏计算出散列值，消息不统计算出来的散列值也不一样，并且具备单向性。<br>
- 应用<br>
1. 根据单向散列函数计算出的散列值（哈希值）可以检测软件是否被篡改。<br>
2. 单向散列函数可用于基于口令的加密。
3. 单向散列函数可以构造消息认证码。
4. 数字签名也会用到单向散列函数。
5. 使用单向散列函数可以构造伪随机数生成器。
6. 利用单相思浓烈函数可以构造一次性口令。

### SHA-1
`SHA-1`是哈希函数的一种。它能够从最大2^64比特的消息中计算出160比特的散列值。<br>

![image](../Src/cr_base_3/1511925105996.png)
<br>
*SHA-1函数的运行总共有四个步骤*

##### 1.填充
sha-1函数的消息长度在0~ 2^64比特之间。每512比特为一个输入分组，若长度不是512比特的整数倍就需要对sha-1信息进行填充。<br>
填充方法是：在消息末尾添加1比特的“1”，在“1”后面联系添加“0”，直到消息长度为512比特的整数倍。但是最后一个分组的最后64比特空出来保存原始信息长度。<br>

##### 2.计算W0~ W79
SHA-1的计算是以输入分组为单位计算的。每个输入分组计算出80个32比特。这些值用到第四步的计算中。首先，一个输入分组分成16组32比特信息，命名为`W0~W15`。<br>
剩余的`W16~W79`的计算方法：Wt=Wt-16 XOR Wt-14 XOR Wt-8 XOR Wt-3循环左移1比特。<br>

##### 3.分组处理
分组处理是为了将输入分组的512比特数据和SHA-1保持的160比特的内部状态（五个缓冲区）进行混合，SHA-1最终输出的160比特散列值，就是处理结束后的内部状态。下图展示的就是输入分组与五个缓冲区是怎么混合的！

![image](../Src/cr_base_3/1511925192533.png)


##### 4.单步处理
分组处理的80个步骤中的每一步的详细过程都是如下图所示。主要是为了使内部状态（缓冲区A,B,C,D,E）产生变化。

![image](../Src/cr_base_3/1511925231246.png)

## [MD5](http://blog.csdn.net/xiaofengcanyuexj/article/details/37698801)
MD5即信息摘要算法第五版。是一种有广泛应用的哈希函数。用来提供消息的完整性保护。他能够对消息产生128比特的散列值。<br>
MD5是一种不可逆的算法，通过信息摘要算法得到的信息是不完整的，所以也不能得到原始数据。<br>
MD5以512比特信息分组来处理输入的信息，每一个分组又被划分成16组32比特分组。经一系列的算法变化得到4个32比特分组，这个四个32比特分组生成128比特的散列值。<br>
在网上经常会看到32位和16位的MD5值，两者是有部分相同的，32位的MD5值去掉前八位和后八位就是16位了。<br>
**MD5算法流程**
1. 填充
- 参考SHA-1。
2. 设置4个初始参数<br>
- 第一组输入分组需要设置4个32位的链接变量：A=0x01234567;B=0x89abcdef;C=0xfedcba98;D=0x76543210；用来计算信息摘要。
- 四个链接变量复制到a,b,c,d。
- 第二组及后面的输入分组的初始变量是上一组的运算结果。
3. 对输入数据做变换<br>
主循环是4轮操作，每轮操作有16次操作，每次操作是对A,B,C,D中的3个做非线性操作，所得结果加上第4个变量。
- F(X,Y,Z)=(X&Y)|((~X)&Z)
- G(X,Y,Z)=(X&Z)|(Y&(~Z))
- H(X,Y,Z)=X^Y^Z
- I(X,Y,Z)=Y^(X|(~Z))
(&代表与，~代表反，^代表异或，|代表或)<br>

### 应用 ###
1. 防止被篡改
2. 防治直接看到明文
3. 防止抵赖

### 最后一段话！！
CTF密码学部分通常会涉及到逆向，web，代码的知识，各位同学要拓展自己的知识面，以便可以在看到题目的时候想到相应的密码模型。<br>
这里有CTF可能用到的密码的形试和工具，大家自行体验一把。<br>
- [CTF中那些脑洞大开的编码和加密](http://www.360doc.com/content/16/0906/21/27425026_588911412.shtml)
- [CTFtools](https://www.ctftools.com/)


